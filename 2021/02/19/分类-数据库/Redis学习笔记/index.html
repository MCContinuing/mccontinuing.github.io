

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>Redis学习笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>MCContinuing's Library</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Redis学习笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-02-19 10:50" pubdate>
        February 19, 2021 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      16.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      225
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis学习笔记</h1>
            
            <div class="markdown-body">
              <h1 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h1><p>Redis（==R==emote ==Di==ctionary ==S==erver )，即远程字典服务 !</p>
<ul>
<li><p>是一个开源的使用ANSI，C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</p>
</li>
<li><p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步。</p>
</li>
<li><p>是当下最热门的 NoSQL 技术之一，也被人们称之为结构化数据库。</p>
</li>
</ul>
<h2 id="Redis作用"><a href="#Redis作用" class="headerlink" title="Redis作用"></a>Redis作用</h2><ol>
<li>内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）</li>
<li>效率高，可以用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器（浏览量！）</li>
<li>……..</li>
</ol>
<h2 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h2><p>1、多样的数据类型</p>
<p>2、持久化</p>
<p>3、集群</p>
<p>4、事务</p>
<h1 id="Redis服务使用"><a href="#Redis服务使用" class="headerlink" title="Redis服务使用"></a>Redis服务使用</h1><h3 id="启动Redis服务"><a href="#启动Redis服务" class="headerlink" title="启动Redis服务"></a>启动Redis服务</h3><p>通过指定配置文件启动</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210219230530598-1613785778498.png" srcset="/img/loading.gif" alt="image-20210219230530598"></p>
<h3 id="使用redis-cli-进行连接测试！"><a href="#使用redis-cli-进行连接测试！" class="headerlink" title="使用redis-cli 进行连接测试！"></a>使用redis-cli 进行连接测试！</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -p 6379<br></code></pre></td></tr></table></figure>



<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210219230433989-1613785778504.png" srcset="/img/loading.gif" alt="image-20210219230433989"></p>
<h3 id="查看redis的进程是否开启"><a href="#查看redis的进程是否开启" class="headerlink" title="查看redis的进程是否开启"></a>查看redis的进程是否开启</h3><p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210219230704401-1613785778506.png" srcset="/img/loading.gif" alt="image-20210219230704401"></p>
<h3 id="关闭Redis服务-shutdown"><a href="#关闭Redis服务-shutdown" class="headerlink" title="关闭Redis服务 shutdown"></a>关闭Redis服务 <code>shutdown</code></h3><p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210219230827108-1613785778506.png" srcset="/img/loading.gif" alt="image-20210219230827108"></p>
<h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><p>redis默认有16个数据库</p>
<p>默认使用的是第0个</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul>
<li><p>选择数据库 <code>select</code></p>
</li>
<li><p>查看数据库大小 <code>DBSIZE</code></p>
</li>
<li><p>查看数据库所有的key<code>key *</code></p>
</li>
<li><p>清除当前数据库 <code>flushdb</code></p>
</li>
<li><p>清除全部数据库的内容 <code>FLUSHALL</code></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost bin]# redis-server myconfig/redis.conf<br>[root@localhost bin]# redis-cli -p 6379<br>127.0.0.1:6379&gt; select 3 # 选择数据库<br>OK<br>127.0.0.1:6379[3]&gt; DBSIZE # 查看数据库大小<br>(integer) 0<br>127.0.0.1:6379[3]&gt; set name mochen<br>OK<br>127.0.0.1:6379[3]&gt; DBSIZE<br>(integer) 1<br>127.0.0.1:6379[3]&gt; get name<br>&quot;mochen&quot;<br>127.0.0.1:6379[3]&gt; flushdb   #清楚当前数据库<br>OK<br>127.0.0.1:6379[3]&gt; keys *<br>(empty list or set)<br></code></pre></td></tr></table></figure>

<h2 id="Redis-是单线程的"><a href="#Redis-是单线程的" class="headerlink" title="Redis 是单线程的"></a>Redis 是单线程的</h2><p>明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！</p>
<p>Redis 是C 语言写的，官方提供的数据为 100000+ 的QPS，完全不比同样是使用 key-vale的Memecache差！</p>
<p>Redis 为什么单线程还这么快？</p>
<p>1、误区1：高性能的服务器一定是多线程的？<br>2、误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</p>
<p><strong>核心：</strong>redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</p>
<h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><h2 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h2><ul>
<li>keys * 查看所有的key</li>
<li>set name kuangshen set key value</li>
<li>EXISTS name 判断当前的key是否存在</li>
<li>move name 1 移除当前的key</li>
<li>EXPIRE name 10 设置key的过期时间，单位是秒</li>
<li>ttl name 查看当前key的剩余时间</li>
<li>type name 查看当前key的一个类型</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; keys * # 查看所有的key<br>(empty list or set)<br>127.0.0.1:6379&gt; set name kuangshen   # set key<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) &quot;name&quot;<br>127.0.0.1:6379&gt; set age 1<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) &quot;age&quot;<br>2) &quot;name&quot;<br>127.0.0.1:6379&gt; EXISTS name # 判断当前的key是否存在<br>(integer) 1<br>127.0.0.1:6379&gt; EXISTS name1<br>(integer) 0<br>127.0.0.1:6379&gt; move name 1 # 移除当前的key<br>(integer) 1<br>127.0.0.1:6379&gt; keys *<br>1) &quot;age&quot;<br>127.0.0.1:6379&gt; set name qinjiang<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) &quot;age&quot;<br>2) &quot;name&quot;<br>127.0.0.1:6379&gt; clear<br>127.0.0.1:6379&gt; keys *<br>1) &quot;age&quot;<br>2) &quot;name&quot;<br>127.0.0.1:6379&gt; get name<br>&quot;qinjiang&quot;<br>127.0.0.1:6379&gt; EXPIRE name 10 # 设置key的过期时间，单位是秒<br>(integer) 1<br>127.0.0.1:6379&gt; ttl name # 查看当前key的剩余时间<br>(integer) 4<br>127.0.0.1:6379&gt; ttl name<br>(integer) 3<br>127.0.0.1:6379&gt; ttl name<br>(integer) 2<br>127.0.0.1:6379&gt; ttl name<br>(integer) 1<br>127.0.0.1:6379&gt; ttl name<br>(integer) -2<br>127.0.0.1:6379&gt; get name<br>(nil)<br>127.0.0.1:6379&gt; type name # 查看当前key的一个类型！<br>string<br>127.0.0.1:6379&gt; type age<br>string<br></code></pre></td></tr></table></figure>

<p>后面如果遇到不会的命令，可以在官网查看帮助文档！</p>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>90% 的 java程序员使用 redis 只会使用一个String类型！</p>
<ul>
<li><p>set key1 v1 设置值</p>
</li>
<li><p>get key1 获得值</p>
</li>
<li><p>keys * 获得所有的key</p>
</li>
<li><p>EXISTS key1 判断某一个key是否存在</p>
</li>
<li><p>APPEND key1 “hello” 追加字符串，如果当前key不存在，就相当于setkey</p>
</li>
<li><p>STRLEN key1 获取字符串的长度！</p>
</li>
<li><p>incr views 自增1</p>
</li>
<li><p>decr views 自减1</p>
</li>
<li><p>INCRBY views 10 可以设置步长，指定增量！</p>
</li>
<li><p>DECRBY views 5 指定减量</p>
</li>
<li><p>GETRANGE key1 0 3 截取字符串 [0,3]</p>
</li>
<li><p>GETRANGE key1 0 -1 获取全部的字符串 和 get key是一样的</p>
</li>
<li><p>SETRANGE key2 1 xx 替换指定位置开始的字符串！</p>
</li>
<li><p>setex key3 30 “hello” 设置key3 的值为 hello,30秒后过期</p>
<ul>
<li>setex (set with expire) 设置过期时间</li>
</ul>
</li>
<li><p>setnx mykey “redis” 如果mykey 不存在，创建mykey，如果mykey存在，创建失败！</p>
<ul>
<li>setnx (set if not exist) 不存在在设置 （在分布式锁中会常常使用！）</li>
</ul>
</li>
<li><p>mset k1 v1 k2 v2 k3 v3 同时设置多个值</p>
</li>
<li><p>mget k1 k2 k3 同时获取多个值</p>
</li>
<li><p>msetnx k1 v1 k4 v4 msetnx 是一个原子性的操作，要么一起成功，要么一起</p>
</li>
<li><p>mset user:1:name zhangsan user:1:age 2</p>
<ul>
<li><p>对象 set user:1 {name:zhangsan,age:3} # 设置一个user:1 对象 值为 json字符来保存一个对象！</p>
<p>这里的key是一个巧妙的设计： user:{id}:{filed} , 如此设计在Redis中是完全OK了！</p>
</li>
</ul>
</li>
<li><p>mget user:1:name user:1:age</p>
</li>
<li><p>getset db redis 如果不存在值，则返回 nil，并创建key-value值，如果存在值，获取原来的值，并设置新的值</p>
<ul>
<li>getset 先get然后在set</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>127.0.0.1:6379&gt; set key1 v1 # 设置值<br>OK<br>127.0.0.1:6379&gt; get key1 # 获得值<br>&quot;v1&quot;<br>127.0.0.1:6379&gt; keys * # 获得所有的key<br>1) &quot;key1&quot;<br>127.0.0.1:6379&gt; EXISTS key1 # 判断某一个key是否存在<br>(integer) 1<br>127.0.0.1:6379&gt; APPEND key1 &quot;hello&quot; # 追加字符串，如果当前key不存在，就相当于setkey<br>(integer) 7<br>127.0.0.1:6379&gt; get key1<br>&quot;v1hello&quot;<br>127.0.0.1:6379&gt; STRLEN key1 # 获取字符串的长度！<br>(integer) 7<br>127.0.0.1:6379&gt; APPEND key1 &quot;,kaungshen&quot;<br>(integer) 17<br>127.0.0.1:6379&gt; STRLEN key1<br>(integer) 17<br>127.0.0.1:6379&gt; get key1<br>&quot;v1hello,kaungshen&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br><span class="hljs-meta">#</span><span class="bash"> i++</span><br><span class="hljs-meta">#</span><span class="bash"> 步长 i+=</span><br>127.0.0.1:6379&gt; set views 0 # 初始浏览量为0<br>OK<br>127.0.0.1:6379&gt; get views<br>&quot;0&quot;<br>127.0.0.1:6379&gt; incr views # 自增1 浏览量变为1<br>(integer) 1<br>127.0.0.1:6379&gt; incr views<br>(integer) 2<br>127.0.0.1:6379&gt; get views<br>&quot;2&quot;<br>127.0.0.1:6379&gt; decr views # 自减1 浏览量-1<br>(integer) 1<br>127.0.0.1:6379&gt; decr views<br>(integer) 0<br>127.0.0.1:6379&gt; decr views<br>(integer) -1<br>127.0.0.1:6379&gt; get views<br>&quot;-1&quot;<br>127.0.0.1:6379&gt; INCRBY views 10 # 可以设置步长，指定增量！<br>(integer) 9<br>127.0.0.1:6379&gt; INCRBY views 10<br>(integer) 19<br>127.0.0.1:6379&gt; DECRBY views 5<br>(integer) 14<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br><span class="hljs-meta">#</span><span class="bash"> 字符串范围 range</span><br>127.0.0.1:6379&gt; set key1 &quot;hello,kuangshen&quot; # 设置 key1 的值<br>OK<br>127.0.0.1:6379&gt; get key1<br>&quot;hello,kuangshen&quot;<br>127.0.0.1:6379&gt; GETRANGE key1 0 3 # 截取字符串 [0,3]<br>&quot;hell&quot;<br>127.0.0.1:6379&gt; GETRANGE key1 0 -1 # 获取全部的字符串 和 get key是一样的<br>&quot;hello,kuangshen&quot;<br><span class="hljs-meta">#</span><span class="bash"> 替换！</span><br>127.0.0.1:6379&gt; set key2 abcdefg<br>OK<br>127.0.0.1:6379&gt; get key2<br>&quot;abcdefg&quot;<br>127.0.0.1:6379&gt; SETRANGE key2 1 xx # 替换指定位置开始的字符串！<br>(integer) 7<br>127.0.0.1:6379&gt; get key2<br>&quot;axxdefg&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br><span class="hljs-meta">#</span><span class="bash"> setex (<span class="hljs-built_in">set</span> with expire) <span class="hljs-comment"># 设置过期时间</span></span><br><span class="hljs-meta">#</span><span class="bash"> setnx (<span class="hljs-built_in">set</span> <span class="hljs-keyword">if</span> not exist) <span class="hljs-comment"># 不存在在设置 （在分布式锁中会常常使用！）</span></span><br>127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot; # 设置key3 的值为 hello,30秒后过期<br>OK<br>127.0.0.1:6379&gt; ttl key3<br>(integer) 26<br>127.0.0.1:6379&gt; get key3<br>&quot;hello&quot;<br>127.0.0.1:6379&gt; setnx mykey &quot;redis&quot; # 如果mykey 不存在，创建mykey<br>(integer) 1<br>127.0.0.1:6379&gt; keys *<br>1) &quot;key2&quot;<br>2) &quot;mykey&quot;<br>3) &quot;key1&quot;<br>127.0.0.1:6379&gt; ttl key3<br>(integer) -2<br>127.0.0.1:6379&gt; setnx mykey &quot;MongoDB&quot; # 如果mykey存在，创建失败！<br>(integer) 0<br>127.0.0.1:6379&gt; get mykey<br>&quot;redis&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>mset<br>mget<br>127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 # 同时设置多个值<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) &quot;k1&quot;<br>2) &quot;k2&quot;<br>3) &quot;k3&quot;<br>127.0.0.1:6379&gt; mget k1 k2 k3 # 同时获取多个值<br>1) &quot;v1&quot;<br>2) &quot;v2&quot;<br>3) &quot;v3&quot;<br>127.0.0.1:6379&gt; msetnx k1 v1 k4 v4 # msetnx 是一个原子性的操作，要么一起成功，要么一起<br>失败！<br>(integer) 0<br>127.0.0.1:6379&gt; get k4<br>(nil)<br><span class="hljs-meta">#</span><span class="bash"> 对象</span><br>set user:1 &#123;name:zhangsan,age:3&#125; # 设置一个user:1 对象 值为 json字符来保存一个对象！<br><span class="hljs-meta">#</span><span class="bash"> 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125; , 如此设计在Redis中是完全OK了！</span><br>127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2<br>OK<br>127.0.0.1:6379&gt; mget user:1:name user:1:age<br>1) &quot;zhangsan&quot;<br>2) &quot;2&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>getset # 先get然后在set<br>127.0.0.1:6379&gt; getset db redis # 如果不存在值，则返回 nil，并创建key-value值<br>(nil)<br>127.0.0.1:6379&gt; get db<br>&quot;redis<br>127.0.0.1:6379&gt; getset db mongodb # 如果存在值，获取原来的值，并设置新的值<br>&quot;redis&quot;<br>127.0.0.1:6379&gt; get db<br>&quot;mongodb&quot;<br></code></pre></td></tr></table></figure>

<p>数据结构是相同的！</p>
<p>String类似的使用场景：value除了是我们的字符串还可以是我们的数字！</p>
<ul>
<li>计数器</li>
<li>统计多单位的数量</li>
<li>粉丝数</li>
<li>对象缓存存储！</li>
</ul>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！</p>
<p>所有的list命令都是用l开头的，Redis不区分大小命令</p>
<ul>
<li>LPUSH list one # 将一个值或者多个值，插入到列表头部 （左）</li>
<li>LRANGE list 0 -1 # 获取list中值！</li>
<li>LRANGE list 0 1 # 通过区间获取具体的值！</li>
<li>Rpush list righr # 将一个值或者多个值，插入到列表位部 （右）</li>
<li>Lpop list # 移除list的第一个元素</li>
<li>Rpop list # 移除list的最后一个元素</li>
<li>lindex list 1 # 通过下标获得 list 中的某一个值！</li>
<li>Llen list # 返回列表的长度</li>
<li>lrem list 1 one # 移除list集合中指定个数的value，精确匹配</li>
<li>ltrim mylist 1 2 # 通过下标截取指定的长度，这个list已经被改变了，只剩下截取的元素！</li>
<li>rpoplpush mylist myotherlist # 移除列表的最后一个元素，将他移动到新的</li>
<li>EXISTS list # 判断这个列表是否存在</li>
<li>lset list 0 item # 如果不存在列表我们去更新就会报错， 如果存在，更新当前下标的值</li>
<li>LINSERT mylist before “world” “other”</li>
<li>LINSERT mylist after “world” “new” # 将某个具体的value插入到列把你中某个元素的前面或者后面！</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>127.0.0.1:6379&gt; LPUSH list one # 将一个值或者多个值，插入到列表头部 （左）<br>(integer) 1<br>127.0.0.1:6379&gt; LPUSH list two<br>(integer) 2<br>127.0.0.1:6379&gt; LPUSH list three<br>(integer) 3<br>127.0.0.1:6379&gt; LRANGE list 0 -1 # 获取list中值！<br>1) &quot;three&quot;<br>2) &quot;two&quot;<br>3) &quot;one&quot;<br>127.0.0.1:6379&gt; LRANGE list 0 1 # 通过区间获取具体的值！<br>1) &quot;three&quot;<br>2) &quot;two&quot;<br>127.0.0.1:6379&gt; Rpush list righr # 将一个值或者多个值，插入到列表位部 （右）<br>(integer) 4<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;three&quot;<br>2) &quot;two&quot;<br>3) &quot;one&quot;<br>4) &quot;righr&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>LPOP<br>RPOP<br>127.0.0.1:6379&gt; Lpop list # 移除list的第一个元素<br>&quot;three&quot;<br>127.0.0.1:6379&gt; Rpop list # 移除list的最后一个元素<br>&quot;righr&quot;<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;two&quot;<br>2) &quot;one&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>Lindex<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;two&quot;<br>2) &quot;one&quot;<br>127.0.0.1:6379&gt; lindex list 1 # 通过下标获得 list 中的某一个值！<br>&quot;one&quot;<br>127.0.0.1:6379&gt; lindex list 0<br>&quot;two&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>Llen<br>127.0.0.1:6379&gt; Lpush list one<br>(integer) 1<br>127.0.0.1:6379&gt; Lpush list two<br>(integer) 2<br>127.0.0.1:6379&gt; Lpush list three<br>(integer) 3<br>127.0.0.1:6379&gt; Llen list # 返回列表的长度<br>(integer) 3<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>移除指定的值！<br>取关 uid<br>Lrem<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;three&quot;<br>2) &quot;three&quot;<br>3) &quot;two&quot;<br>4) &quot;one&quot;<br>127.0.0.1:6379&gt; lrem list 1 one # 移除list集合中指定个数的value，精确匹配<br>(integer) 1<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;three&quot;<br>2) &quot;three&quot;<br>3) &quot;two&quot;<br>127.0.0.1:6379&gt; lrem list 1 three<br>(integer) 1<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;three&quot;<br>2) &quot;two&quot;<br>127.0.0.1:6379&gt; Lpush list three<br>(integer) 3<br>127.0.0.1:6379&gt; lrem list 2 three<br>(integer) 2<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;two&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>trim 修剪。； list 截断!<br>127.0.0.1:6379&gt; keys *<br>(empty list or set)<br>127.0.0.1:6379&gt; Rpush mylist &quot;hello&quot;<br>(integer) 1<br>127.0.0.1:6379&gt; Rpush mylist &quot;hello1&quot;<br>(integer) 2<br>127.0.0.1:6379&gt; Rpush mylist &quot;hello2&quot;<br>(integer) 3<br>127.0.0.1:6379&gt; Rpush mylist &quot;hello3&quot;<br>(integer) 4<br>127.0.0.1:6379&gt; ltrim mylist 1 2 # 通过下标截取指定的长度，这个list已经被改变了，截断了，只剩下截取的元素！<br>OK<br>127.0.0.1:6379&gt; LRANGE mylist 0 -1<br>1) &quot;hello1&quot;<br>2) &quot;hello2&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>rpoplpush # 移除列表的最后一个元素，将他移动到新的列表中！<br>127.0.0.1:6379&gt; rpush mylist &quot;hello&quot;<br>(integer) 1<br>127.0.0.1:6379&gt; rpush mylist &quot;hello1&quot;<br>(integer) 2<br>127.0.0.1:6379&gt; rpush mylist &quot;hello2&quot;<br>(integer) 3<br>127.0.0.1:6379&gt; rpoplpush mylist myotherlist # 移除列表的最后一个元素，将他移动到新的列表中！<br>&quot;hello2&quot;<br>127.0.0.1:6379&gt; lrange mylist 0 -1 # 查看原来的列表<br>1) &quot;hello&quot;<br>2) &quot;hello1&quot;<br>127.0.0.1:6379&gt; lrange myotherlist 0 -1 # 查看目标列表中，确实存在改值！<br>1) &quot;hello2&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>lset 将列表中指定下标的值替换为另外一个值，更新操作<br>127.0.0.1:6379&gt; EXISTS list # 判断这个列表是否存在<br>(integer) 0<br>127.0.0.1:6379&gt; lset list 0 item # 如果不存在列表我们去更新就会报错<br>(error) ERR no such key<br>127.0.0.1:6379&gt; lpush list value1<br>(integer) 1<br>127.0.0.1:6379&gt; LRANGE list 0 0<br>1) &quot;value1&quot;<br>127.0.0.1:6379&gt; lset list 0 item # 如果存在，更新当前下标的值<br>OK<br>127.0.0.1:6379&gt; LRANGE list 0 0<br>1) &quot;item&quot;<br>127.0.0.1:6379&gt; lset list 1 other # 如果不存在，则会报错！<br>(error) ERR index out of range<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>linsert # 将某个具体的value插入到列把你中某个元素的前面或者后面！<br>127.0.0.1:6379&gt; Rpush mylist &quot;hello&quot;<br>(integer) 1<br>127.0.0.1:6379&gt; Rpush mylist &quot;world&quot;<br>(integer) 2<br>127.0.0.1:6379&gt; LINSERT mylist before &quot;world&quot; &quot;other&quot;<br>(integer) 3<br>127.0.0.1:6379&gt; LRANGE mylist 0 -1<br>1) &quot;hello&quot;<br>2) &quot;other&quot;<br>3) &quot;world&quot;<br>127.0.0.1:6379&gt; LINSERT mylist after world new<br>(integer) 4<br>127.0.0.1:6379&gt; LRANGE mylist 0 -1<br>1) &quot;hello&quot;<br>2) &quot;other&quot;<br>3) &quot;world&quot;<br>4) &quot;new&quot;<br></code></pre></td></tr></table></figure>

<p>小结</p>
<ul>
<li>他实际上是一个链表，before Node after ， left，right 都可以插入值</li>
<li>如果key 不存在，创建新的链表</li>
<li>如果key存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在！</li>
<li>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~</li>
</ul>
<p>消息排队：消息队列 （Lpush Rpop）， 栈（ Lpush Lpop）！</p>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>set中的值是不能重读的！</p>
<ul>
<li>list 是有序列表，值可重复</li>
<li>set 是无序列表，值不可重复</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>127.0.0.1:6379&gt; sadd myset &quot;hello&quot; # set集合中添加元素<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset &quot;lovekuangshen&quot;<br>(integer) 1<br>127.0.0.1:6379&gt; SMEMBERS myset # 查看指定set的所有值<br>1) &quot;hello&quot;<br>2) &quot;lovekuangshen&quot;<br>3) &quot;kuangshen&quot;<br>127.0.0.1:6379&gt; SISMEMBER myset hello # 判断某一个值是不是在set集合中！<br>(integer) 1<br>127.0.0.1:6379&gt; SISMEMBER myset world<br>(integer) 0<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>127.0.0.1:6379&gt; scard myset # 获取set集合中的内容元素个数！<br>(integer) 4<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>rem<br>127.0.0.1:6379&gt; srem myset hello # 移除set集合中的指定元素<br>(integer) 1<br>127.0.0.1:6379&gt; scard myset<br>(integer) 3<br>127.0.0.1:6379&gt; SMEMBERS myset<br>1) &quot;lovekuangshen2&quot;<br>2) &quot;lovekuangshen&quot;<br>3) &quot;kuangshen&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>set 无序不重复集合。抽随机！<br>127.0.0.1:6379&gt; SMEMBERS myset<br>1) &quot;lovekuangshen2&quot;<br>2) &quot;lovekuangshen&quot;<br>3) &quot;kuangshen&quot;<br>127.0.0.1:6379&gt; SRANDMEMBER myset # 随机抽选出一个元素<br>&quot;kuangshen&quot;<br>127.0.0.1:6379&gt; SRANDMEMBER myset<br>&quot;kuangshen&quot;<br>127.0.0.1:6379&gt; SRANDMEMBER myset<br>&quot;kuangshen&quot;<br>127.0.0.1:6379&gt; SRANDMEMBER myset<br>&quot;kuangshen&quot;<br>127.0.0.1:6379&gt; SRANDMEMBER myset 2 # 随机抽选出指定个数的元素<br>bilibili：狂神说Java<br>1) &quot;lovekuangshen&quot;<br>2) &quot;lovekuangshen2&quot;<br>127.0.0.1:6379&gt; SRANDMEMBER myset 2<br>1) &quot;lovekuangshen&quot;<br>2) &quot;lovekuangshen2&quot;<br>127.0.0.1:6379&gt; SRANDMEMBER myset # 随机抽选出一个元素<br>&quot;lovekuangshen2&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>删除定的key，随机删除key！<br>127.0.0.1:6379&gt; SMEMBERS myset<br>1) &quot;lovekuangshen2&quot;<br>2) &quot;lovekuangshen&quot;<br>3) &quot;kuangshen&quot;<br>127.0.0.1:6379&gt; spop myset # 随机删除一些set集合中的元素！<br>&quot;lovekuangshen2&quot;<br>127.0.0.1:6379&gt; spop myset<br>&quot;lovekuangshen&quot;<br>127.0.0.1:6379&gt; SMEMBERS myset<br>1) &quot;kuangshen&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>将一个指定的值，移动到另外一个set集合！<br>127.0.0.1:6379&gt; sadd myset &quot;hello&quot;<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset &quot;world&quot;<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset2 &quot;set2&quot;<br>(integer) 1<br>127.0.0.1:6379&gt; smove myset myset2 &quot;kuangshen&quot; # 将一个指定的值，移动到另外一个set集合！<br>(integer) 1<br>127.0.0.1:6379&gt; SMEMBERS myset<br>1) &quot;world&quot;<br>2) &quot;hello&quot;<br>127.0.0.1:6379&gt; SMEMBERS myset2<br>1) &quot;kuangshen&quot;<br>2) &quot;set2&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>微博，B站，共同关注！(并集)<br>数字集合类：<br>- 差集 SDIFF<br>- 交集<br>- 并集<br>127.0.0.1:6379&gt; SDIFF key1 key2 # 差集<br>1) &quot;b&quot;<br>2) &quot;a&quot;<br>127.0.0.1:6379&gt; SINTER key1 key2 # 交集 共同好友就可以这样实现<br>1) &quot;c&quot;<br>127.0.0.1:6379&gt; SUNION key1 key2 # 并集<br>1) &quot;b&quot;<br>2) &quot;c&quot;<br>3) &quot;e&quot;<br>4) &quot;a&quot;<br>5) &quot;d&quot;<br></code></pre></td></tr></table></figure>

<h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Map集合，key-map! 时候这个值是一个map集合！ 本质和String类型没有太大区别，还是一个简单的key-vlaue！</p>
<p>set myhash field kuangshen</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>127.0.0.1:6379&gt; hset myhash field1 kuangshen # set一个具体 key-vlaue<br>(integer) 1<br>127.0.0.1:6379&gt; hget myhash field1 # 获取一个字段值<br>&quot;kuangshen&quot;<br>127.0.0.1:6379&gt; hmset myhash field1 hello field2 world # set多个 key-vlaue<br>OK<br>127.0.0.1:6379&gt; hmget myhash field1 field2 # 获取多个字段值<br>1) &quot;hello&quot;<br>2) &quot;world&quot;<br>127.0.0.1:6379&gt; hgetall myhash # 获取全部的数据，<br>1) &quot;field1&quot;<br>2) &quot;hello&quot;<br>3) &quot;field2&quot;<br>4) &quot;world&quot;<br>127.0.0.1:6379&gt; hdel myhash field1 # 删除hash指定key字段！对应的value值也就消失了！<br>(integer) 1<br>127.0.0.1:6379&gt; hgetall myhash<br>1) &quot;field2&quot;<br>2) &quot;world&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>hlen<br>127.0.0.1:6379&gt; hmset myhash field1 hello field2 world<br>OK<br>127.0.0.1:6379&gt; HGETALL myhash<br>1) &quot;field2&quot;<br>2) &quot;world&quot;<br>3) &quot;field1&quot;<br>4) &quot;hello&quot;<br>127.0.0.1:6379&gt; hlen myhash # 获取hash表的字段数量！<br>(integer) 2<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>127.0.0.1:6379&gt; HEXISTS myhash field1 # 判断hash中指定字段是否存在！<br>(integer) 1<br>127.0.0.1:6379&gt; HEXISTS myhash field3<br>(integer) 0<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br><span class="hljs-meta">#</span><span class="bash"> 只获得所有field</span><br><span class="hljs-meta">#</span><span class="bash"> 只获得所有value</span><br>127.0.0.1:6379&gt; hkeys myhash # 只获得所有field<br>1) &quot;field2&quot;<br>2) &quot;field1&quot;<br>127.0.0.1:6379&gt; hvals myhash # 只获得所有value<br>1) &quot;world&quot;<br>2) &quot;hello&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>incr decr<br>127.0.0.1:6379&gt; hset myhash field3 5 #指定增量！<br>(integer) 1<br>127.0.0.1:6379&gt; HINCRBY myhash field3 1<br>(integer) 6<br>127.0.0.1:6379&gt; HINCRBY myhash field3 -1<br>(integer) 5<br>127.0.0.1:6379&gt; hsetnx myhash field4 hello # 如果不存在则可以设置<br>(integer) 1<br>127.0.0.1:6379&gt; hsetnx myhash field4 world # 如果存在则不能设置<br>(integer) 0<br></code></pre></td></tr></table></figure>

<p>hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的存储，String更加适合字符串存储！</p>
<h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><p>在set的基础上，增加了一个值，set k1 v1 zset k1 score1 v1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; zadd myset 1 one # 添加一个值<br>(integer) 1<br>127.0.0.1:6379&gt; zadd myset 2 two 3 three # 添加多个值<br>(integer) 2<br>127.0.0.1:6379&gt; ZRANGE myset 0 -1<br>1) &quot;one&quot;<br>2) &quot;two&quot;<br>3) &quot;three&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>排序如何实现<br>127.0.0.1:6379&gt; zadd salary 2500 xiaohong # 添加三个用户<br>(integer) 1<br>127.0.0.1:6379&gt; zadd salary 5000 zhangsan<br>(integer) 1<br>127.0.0.1:6379&gt; zadd salary 500 kaungshen<br>(integer) 1<br><span class="hljs-meta">#</span><span class="bash"> ZRANGEBYSCORE key min max</span><br>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf # 显示全部的用户 从小到大！<br>1) &quot;kaungshen&quot;<br>2) &quot;xiaohong&quot;<br>3) &quot;zhangsan&quot;<br>127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 # 从大到进行排序！<br>1) &quot;zhangsan&quot;<br>2) &quot;kaungshen&quot;<br>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores # 显示全部的用户并且附带成<br>绩<br>1) &quot;kaungshen&quot;<br>2) &quot;500&quot;<br>3) &quot;xiaohong&quot;<br>4) &quot;2500&quot;<br>5) &quot;zhangsan&quot;<br>6) &quot;5000&quot;<br>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores # 显示工资小于2500员工的升<br>序排序！<br>1) &quot;kaungshen&quot;<br>2) &quot;500&quot;<br>3) &quot;xiaohong&quot;<br>4) &quot;2500&quot;<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br><span class="hljs-meta">#</span><span class="bash"> 移除rem中的元素</span><br>127.0.0.1:6379&gt; zrange salary 0 -1<br>1) &quot;kaungshen&quot;<br>2) &quot;xiaohong&quot;<br>3) &quot;zhangsan&quot;<br>127.0.0.1:6379&gt; zrem salary xiaohong # 移除有序集合中的指定元素<br>(integer) 1<br>127.0.0.1:6379&gt; zrange salary 0 -1<br>1) &quot;kaungshen&quot;<br>2) &quot;zhangsan&quot;<br>127.0.0.1:6379&gt; zcard salary # 获取有序集合中的个数<br>(integer) 2<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><br>127.0.0.1:6379&gt; zadd myset 1 hello<br>(integer) 1<br>127.0.0.1:6379&gt; zadd myset 2 world 3 kuangshen<br>(integer) 2<br>127.0.0.1:6379&gt; zcount myset 1 3 # 获取指定区间的成员数量！<br>(integer) 3<br>127.0.0.1:6379&gt; zcount myset 1 2<br>(integer) 2<br></code></pre></td></tr></table></figure>

<h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1><h2 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h2><p>这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人</p>
<p>可以查询一些测试数据：<a target="_blank" rel="noopener" href="http://www.jsons.cn/lngcodeinfo/0706D99C19A781A3/">http://www.jsons.cn/lngcodeinfo/0706D99C19A781A3/</a></p>
<p>只有 六个命令：</p>
<ul>
<li>GEOADD</li>
<li>GEODIST</li>
<li>GEOHASH</li>
<li>GEOPOS</li>
<li>GEORADIUS</li>
<li>GEORADIUSBYMEMBER</li>
</ul>
<p>官方文档：<a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3685.html">https://www.redis.net.cn/order/3685.html</a></p>
<h3 id="getadd"><a href="#getadd" class="headerlink" title="getadd"></a>getadd</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> getadd 添加地理位置</span><br><span class="hljs-meta">#</span><span class="bash"> 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！</span><br><span class="hljs-meta">#</span><span class="bash"> 有效的经度从-180度到180度。</span><br><span class="hljs-meta">#</span><span class="bash"> 有效的纬度从-85.05112878度到85.05112878度。</span><br><span class="hljs-meta">#</span><span class="bash"> 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span><br><span class="hljs-meta">#</span><span class="bash"> 127.0.0.1:6379&gt; geoadd china:city 39.90 116.40 beijin</span><br>(error) ERR invalid longitude,latitude pair 39.900000,116.400000<br><span class="hljs-meta">#</span><span class="bash"> 参数 key 值（）</span><br>127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing<br>(integer) 1<br>127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai<br>(integer) 1<br>127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqi 114.05 22.52 shengzhen<br>(integer) 2<br>127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian<br>(integer) 2<br></code></pre></td></tr></table></figure>

<h3 id="getpos"><a href="#getpos" class="headerlink" title="getpos"></a>getpos</h3><p>获得当前定位：一定是一个坐标值！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; GEOPOS china:city beijing # 获取指定的城市的经度和纬度！<br>1) 1) &quot;116.39999896287918091&quot;<br>2) &quot;39.90000009167092543&quot;<br>127.0.0.1:6379&gt; GEOPOS china:city beijing chongqi<br>1) 1) &quot;116.39999896287918091&quot;<br>2) &quot;39.90000009167092543&quot;<br>2) 1) &quot;106.49999767541885376&quot;<br>2) &quot;29.52999957900659211&quot;<br></code></pre></td></tr></table></figure>

<h3 id="GEODIST"><a href="#GEODIST" class="headerlink" title="GEODIST"></a>GEODIST</h3><p>两人之间的距离！</p>
<p>单位：</p>
<ul>
<li>m 表示单位为米。</li>
<li>km 表示单位为千米。</li>
<li>mi 表示单位为英里。</li>
<li>ft 表示单位为英尺。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km # 查看上海到北京的直线距离<br>&quot;1067.3788&quot;<br>127.0.0.1:6379&gt; GEODIST china:city beijing chongqi km # 查看重庆到北京的直线距离<br>&quot;1464.0708&quot;<br></code></pre></td></tr></table></figure>

<h3 id="georadius-以给定的经纬度为中心，-找出某一半径内的元素"><a href="#georadius-以给定的经纬度为中心，-找出某一半径内的元素" class="headerlink" title="georadius 以给定的经纬度为中心， 找出某一半径内的元素"></a>georadius 以给定的经纬度为中心， 找出某一半径内的元素</h3><p>我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！</p>
<p>获得指定数量的人，200</p>
<p>所有数据应该都录入：china:city ，才会让结果更加请求！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km # 以110，30 这个经纬度为中心，寻<br>找方圆1000km内的城市<br>1) &quot;chongqi&quot;<br>2) &quot;xian&quot;<br>3) &quot;shengzhen&quot;<br>4) &quot;hangzhou&quot;<br>127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km<br>1) &quot;chongqi&quot;<br>2) &quot;xian&quot;<br>127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist # 显示到中间距离的位置<br>1) 1) &quot;chongqi&quot;<br>2) &quot;341.9374&quot;<br>2) 1) &quot;xian&quot;<br>2) &quot;483.8340&quot;<br>127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withcoord # 显示他人的定位信息<br>1) 1) &quot;chongqi&quot;<br>2) 1) &quot;106.49999767541885376&quot;<br>2) &quot;29.52999957900659211&quot;<br>2) 1) &quot;xian&quot;<br>2) 1) &quot;108.96000176668167114&quot;<br>2) &quot;34.25999964418929977&quot;<br>127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 1 #<br>筛选出指定的结果！<br>1) 1) &quot;chongqi&quot;<br>2) &quot;341.9374&quot;<br>3) 1) &quot;106.49999767541885376&quot;<br>2) &quot;29.52999957900659211&quot;<br>127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 2<br>1) 1) &quot;chongqi&quot;<br>2) &quot;341.9374&quot;<br>3) 1) &quot;106.49999767541885376&quot;<br>2) &quot;29.52999957900659211&quot;<br>2) 1) &quot;xian&quot;<br>2) &quot;483.8340&quot;<br>3) 1) &quot;108.96000176668167114&quot;<br>2) &quot;34.25999964418929977&quot;<br></code></pre></td></tr></table></figure>

<h3 id="GEORADIUSBYMEMBER"><a href="#GEORADIUSBYMEMBER" class="headerlink" title="GEORADIUSBYMEMBER"></a>GEORADIUSBYMEMBER</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 找出位于指定元素周围的其他元素！</span><br>127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km<br>1) &quot;beijing&quot;<br>2) &quot;xian&quot;<br>127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shanghai 400 km<br>1) &quot;hangzhou&quot;<br>2) &quot;shanghai&quot;<br></code></pre></td></tr></table></figure>

<h3 id="GEOHASH-命令-返回一个或多个位置元素的-Geohash-表示"><a href="#GEOHASH-命令-返回一个或多个位置元素的-Geohash-表示" class="headerlink" title="GEOHASH 命令 - 返回一个或多个位置元素的 Geohash 表示"></a>GEOHASH 命令 - 返回一个或多个位置元素的 Geohash 表示</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！</span><br>127.0.0.1:6379&gt; geohash china:city beijing chongqi<br>1) &quot;wx4fbxxfke0&quot;<br>2) &quot;wm5xzrybty0&quot;<br></code></pre></td></tr></table></figure>

<h3 id="GEO-底层的实现原理其实就是-Zset！我们可以使用Zset命令来操作geo！"><a href="#GEO-底层的实现原理其实就是-Zset！我们可以使用Zset命令来操作geo！" class="headerlink" title="GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！"></a>GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; ZRANGE china:city 0 -1 # 查看地图中全部的元素<br>1) &quot;chongqi&quot;<br>2) &quot;xian&quot;<br>3) &quot;shengzhen&quot;<br>4) &quot;hangzhou&quot;<br>5) &quot;shanghai&quot;<br>6) &quot;beijing&quot;<br>127.0.0.1:6379&gt; zrem china:city beijing # 移除指定元素！<br>(integer) 1<br>127.0.0.1:6379&gt; ZRANGE china:city 0 -1<br>1) &quot;chongqi&quot;<br>2) &quot;xian&quot;<br>3) &quot;shengzhen&quot;<br>4) &quot;hangzhou&quot;<br>5) &quot;shanghai&quot;<br></code></pre></td></tr></table></figure>

<h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><p>Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！</p>
<p>Redis Hyperloglog 基数统计的算法！</p>
<p>优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存！如果要从内存角度来比较的话 Hyperloglog 首选！</p>
<p><code>网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）</code></p>
<p>传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 !</p>
<p>这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；</p>
<p>0.81% 错误率！ 统计UV任务，可以忽略不计的！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; PFadd mykey a b c d e f g h i j # 创建第一组元素 mykey<br>(integer) 1<br>127.0.0.1:6379&gt; PFCOUNT mykey # 统计 mykey 元素的基数数量<br>(integer) 10<br>127.0.0.1:6379&gt; PFadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2<br>(integer) 1<br>127.0.0.1:6379&gt; PFCOUNT mykey2<br>(integer) 9<br>127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2 # 合并两组 mykey mykey2 =&gt; mykey3 并集<br>OK<br>127.0.0.1:6379&gt; PFCOUNT mykey3 # 看并集的数量！<br>(integer) 15<br><br></code></pre></td></tr></table></figure>

<p>如果允许容错，那么一定可以使用 Hyperloglog </p>
<p>如果不允许容错，就使用 set 或者自己的数据类型即可</p>
<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><h4 id="位存储"><a href="#位存储" class="headerlink" title="位存储"></a>位存储</h4><p>统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用Bitmaps！</p>
<p>Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！</p>
<p>365 天 = 365 bit 1字节 = 8bit 46 个字节左右！</p>
<p>使用bitmap 来记录 周一到周日的打卡！</p>
<p>周一：1 周二：0 周三：0 周四：1 ……</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210116180909199.png" srcset="/img/loading.gif"></p>
<p>查看某一天是否有打卡！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; getbit sign 3<br>(integer) 1<br>127.0.0.1:6379&gt; getbit sign 6<br>(integer) 0<br></code></pre></td></tr></table></figure>

<p>统计操作，统计 打卡的天数！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; bitcount sign # 统计这周的打卡记录，就可以看到是否有全勤！<br>(integer) 3<br></code></pre></td></tr></table></figure>

<h1 id="事务-原子性"><a href="#事务-原子性" class="headerlink" title="事务(原子性)"></a>事务(原子性)</h1><p><strong>Redis事务没有没有隔离级别的概念！</strong></p>
<p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！ExecRedis单条命令式保存原子性的，但是事务不保证原子性！</p>
<p>redis的事务：</p>
<ul>
<li>开启事务（multi）</li>
<li>命令入队（……）</li>
<li>执行事务（exec）</li>
</ul>
<p>正常执行事务！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi # 开启事务<br>OK<br><span class="hljs-meta">#</span><span class="bash"> 命令入队</span><br>127.0.0.1:6379&gt; set k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; get k2<br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; exec # 执行事务<br>1) OK<br>2) OK<br>3) &quot;v2&quot;<br>4) OK<br></code></pre></td></tr></table></figure>

<p>放弃事务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi # 开启事务<br>OK<br>127.0.0.1:6379&gt; set k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; set k4 v4<br>QUEUED<br>127.0.0.1:6379&gt; DISCARD # 取消事务<br>OK<br>127.0.0.1:6379&gt; get k4 # 事务队列中命令都不会被执行！<br>(nil)<br></code></pre></td></tr></table></figure>

<p>编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; set k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; getset k3 # 错误的命令<br>(error) ERR wrong number of arguments for &#x27;getset&#x27; command<br>127.0.0.1:6379&gt; set k4 v4<br>QUEUED<br>127.0.0.1:6379&gt; set k5 v5<br>QUEUED<br>127.0.0.1:6379&gt; exec # 执行事务报错！<br>(error) EXECABORT Transaction discarded because of previous errors.<br>127.0.0.1:6379&gt; get k5 # 所有的命令都不会被执行！<br>(nil)<br></code></pre></td></tr></table></figure>

<p>运行时异常（1/0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set k1 &quot;v1&quot;<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; incr k1 # 会执行的时候失败！<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; get k3<br>QUEUED<br>127.0.0.1:6379&gt; exec<br>1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是依旧正常执行成功了！<br>2) OK<br>3) OK<br>4) &quot;v3&quot;<br>127.0.0.1:6379&gt; get k2<br>&quot;v2&quot;<br>127.0.0.1:6379&gt; get k3<br>&quot;v3&quot;<br></code></pre></td></tr></table></figure>

<p>监控！ Watch （面试常问！）</p>
<p><strong>悲观锁：</strong></p>
<ul>
<li>很悲观，认为什么时候都会出问题，无论做什么都会加锁！</li>
</ul>
<p><strong>乐观锁</strong>：</p>
<ul>
<li>很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否有人修改过这个数据，</li>
<li>获取version</li>
<li>更新的时候比较 version</li>
</ul>
<p>Redis测监视测试</p>
<p>正常执行成功！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set money 100<br>OK<br>127.0.0.1:6379&gt; set out 0<br>OK<br>127.0.0.1:6379&gt; watch money # 监视 money 对象<br>OK<br>127.0.0.1:6379&gt; multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！<br>OK<br>127.0.0.1:6379&gt; DECRBY money 20<br>QUEUED<br>127.0.0.1:6379&gt; INCRBY out 20<br>QUEUED<br>127.0.0.1:6379&gt; exec<br>1) (integer) 80<br>2) (integer) 20<br></code></pre></td></tr></table></figure>

<p>测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; watch money # 监视 money<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; DECRBY money 10<br>QUEUED<br>127.0.0.1:6379&gt; INCRBY out 10<br>QUEUED<br>127.0.0.1:6379&gt; exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败！<br>(nil)<br><br></code></pre></td></tr></table></figure>

<p>如果修改失败，获取最新的值就好</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210220170403756.png" srcset="/img/loading.gif" alt="image-20210220170403756"></p>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>我们要使用 Java 来操作 Redis，知其然并知其所以然，授人以渔！ 学习不能急躁，慢慢来会很快！</p>
<p>什么是Jedis ？ 是 Redis 官方推荐的 java连接开发工具！ 使用Java 操作Redis 中间件！如果你要使用 java操作redis，那么一定要对Jedis 十分的熟悉！</p>
<p>测试</p>
<p>新建空项目（空项目容易存在以下两个问题）</p>
<p>注意要把jdk和lambdas配置好</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210220212237065.png" srcset="/img/loading.gif" alt="image-20210220212237065"></p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210220212313834.png" srcset="/img/loading.gif" alt="image-20210220212313834"></p>
<p>注意修改Java版本</p>
<p>![image-20210220212442237](Redis学习笔记/image-20210220212442237.png</p>
<p>1、导入对应的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--fastjson--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.62<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2、编码测试：</p>
<ul>
<li>连接数据库</li>
<li>操作命令</li>
<li>断开连接！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPing</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1、 new Jedis 对象即可</span><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">// jedis 所有的命令就是我们之前学习的所有指令！所以之前的指令学习很重要！</span><br>        System.out.println(jedis.ping());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210220214347906.png" srcset="/img/loading.gif" alt="image-20210220214347906"></p>
<h3 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h3><p>String</p>
<p>List</p>
<p>Set</p>
<p>Hash</p>
<p>Zset</p>
<p>所有的api命令，就是我们对应的上面学习的指令，一个都没有变化！</p>
<p>事务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTX</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        jedis.flushDB();<br>        JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();<br>        jsonObject.put(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;kuangshen&quot;</span>);<br>        <span class="hljs-comment">// 开启事务</span><br>        Transaction multi = jedis.multi();<br>        String result = jsonObject.toJSONString();<br>        <span class="hljs-comment">// jedis.watch(result)</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            multi.set(<span class="hljs-string">&quot;user1&quot;</span>,result);<br>            multi.set(<span class="hljs-string">&quot;user2&quot;</span>,result);<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span> ; <span class="hljs-comment">// 代码抛出异常事务，执行失败！</span><br>            multi.exec(); <span class="hljs-comment">// 执行事务！</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            multi.discard(); <span class="hljs-comment">// 放弃事务</span><br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(jedis.get(<span class="hljs-string">&quot;user1&quot;</span>));<br>            System.out.println(jedis.get(<span class="hljs-string">&quot;user2&quot;</span>));<br>            jedis.close(); <span class="hljs-comment">// 关闭连接</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210220220954844.png" srcset="/img/loading.gif" alt="image-20210220220954844"></p>
<h1 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h1><p>SpringBoot 操作数据：spring-data jpa jdbc mongodb redis！</p>
<p>SpringData 也是和 SpringBoot 齐名的项目！</p>
<p>说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?</p>
<p>jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接池！ 更像 BIO 模式</p>
<p>lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 NIO 模式</p>
<p>新建spring项目，将需要的都勾选上（web springredis等等）</p>
<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span> <span class="hljs-comment">// 我们可以自己定义一个redisTemplate来替换这个默认的！</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory</span></span><br><span class="hljs-function"><span class="hljs-params">                                                       redisConnectionFactory)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;<br>    <span class="hljs-comment">// 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！</span><br>    <span class="hljs-comment">// 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object&gt;</span><br>    RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>    template.setConnectionFactory(redisConnectionFactory);<br>    <span class="hljs-keyword">return</span> template;<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span> <span class="hljs-comment">// 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory</span></span><br><span class="hljs-function"><span class="hljs-params">                                                   redisConnectionFactory)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;<br>    StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();<br>    template.setConnectionFactory(redisConnectionFactory);<br>    <span class="hljs-keyword">return</span> template;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>整合测试</p>
<p>1、导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 操作redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2、配置连接</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 配置redis</span><br><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">127.0.0.1</span><br><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><br></code></pre></td></tr></table></figure>

<p>3、测试！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Redis02SpringbootApplicationTests</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span><br>        <span class="hljs-comment">// opsForValue 操作字符串 类似String</span><br>        <span class="hljs-comment">// opsForList 操作List 类似List</span><br>        <span class="hljs-comment">// opsForSet</span><br>        <span class="hljs-comment">// opsForHash</span><br>        <span class="hljs-comment">// opsForZSet</span><br>        <span class="hljs-comment">// opsForGeo</span><br>        <span class="hljs-comment">// opsForHyperLogLog</span><br>        <span class="hljs-comment">// 除了进本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的</span><br>        CRUD<br>            <span class="hljs-comment">// 获取redis的连接对象</span><br>            <span class="hljs-comment">// RedisConnection connection =</span><br>            redisTemplate.getConnectionFactory().getConnection();<br>        <span class="hljs-comment">// connection.flushDb();</span><br>        <span class="hljs-comment">// connection.flushAll();</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;mykey&quot;</span>,<span class="hljs-string">&quot;关注狂神说公众号&quot;</span>);<br>        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">&quot;mykey&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：对于所有的对象都需要序列化</p>
<p>我们来编写一个自己的 RedisTemplete</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<br>    <span class="hljs-comment">// 这是我给大家写好的一个固定模板，大家在企业中，拿去就可以直接使用！</span><br>    <span class="hljs-comment">// 自己定义了一个 RedisTemplate</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>        <span class="hljs-comment">// 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt;</span><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;String, Object&gt;();<br>        template.setConnectionFactory(factory);<br>        <span class="hljs-comment">// Json序列化配置</span><br>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br>        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        <span class="hljs-comment">// String 的序列化</span><br>        StringRedisSerializer stringRedisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br>        <span class="hljs-comment">// key采用String的序列化方式</span><br>        template.setKeySerializer(stringRedisSerializer);<br>        <span class="hljs-comment">// hash的key也采用String的序列化方式</span><br>        template.setHashKeySerializer(stringRedisSerializer);<br>        <span class="hljs-comment">// value序列化方式采用jackson</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-comment">// hash的value序列化方式采用jackson</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        template.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h1><p><strong>单位</strong></p>
<p>（配置文件 unit单位 对大小写不敏感）</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221105316873.png" srcset="/img/loading.gif" alt="image-20210221105316873"></p>
<p><strong>包含</strong></p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221105511482.png" srcset="/img/loading.gif" alt="image-20210221105511482"></p>
<p><strong>网络</strong></p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221105720061.png" srcset="/img/loading.gif" alt="image-20210221105720061"></p>
<p><strong>通用GENERAL</strong></p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221110130089.png" srcset="/img/loading.gif" alt="image-20210221110130089"></p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221110623621.png" srcset="/img/loading.gif" alt="image-20210221110623621"></p>
<p><strong>快照</strong></p>
<p>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof</p>
<p>redis 是内存数据库，如果没有持久化，那么数据断电及失！</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221112246155.png" srcset="/img/loading.gif" alt="image-20210221112246155"></p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221112357621.png" srcset="/img/loading.gif" alt="image-20210221112357621"></p>
<p><strong>安全</strong></p>
<p>可以在这里设置redis的密码，默认是没有密码！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; ping<br>PONG<br>127.0.0.1:6379&gt; config get requirepass # 获取redis的密码<br>1) &quot;requirepass&quot;<br>2) &quot;&quot;<br>127.0.0.1:6379&gt; config set requirepass &quot;123456&quot; # 设置redis的密码<br>OK<br>127.0.0.1:6379&gt; config get requirepass # 发现所有的命令都没有权限了<br>(error) NOAUTH Authentication required.<br>127.0.0.1:6379&gt; ping<br>(error) NOAUTH Authentication required.<br>127.0.0.1:6379&gt; auth 123456 # 使用密码进行登录！<br>OK<br>127.0.0.1:6379&gt; config get requirepass<br>1) &quot;requirepass&quot;<br>2) &quot;123456&quot;<br></code></pre></td></tr></table></figure>

<p><strong>限制CLIENTS</strong></p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221112940978.png" srcset="/img/loading.gif" alt="image-20210221112940978"></p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221113120634.png" srcset="/img/loading.gif" alt="image-20210221113120634"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">maxmemory-policy noeviction # 内存到达上限之后的处理策略<br>    1、volatile-lru：只对设置了过期时间的key进行LRU（默认值）<br>    2、allkeys-lru ： 删除lru算法的key<br>    3、volatile-random：随机删除即将过期key<br>    4、allkeys-random：随机删除<br>    5、volatile-ttl ： 删除即将过期的<br>    6、noeviction ： 永不过期，返回错误<br></code></pre></td></tr></table></figure>

<p><strong>APPEND ONLY 模式 aof配置</strong></p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221130457247.png" srcset="/img/loading.gif" alt="image-20210221130457247"></p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><p>在主从复制中，rdb就是备用的！在从机上面！</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210119113907477.png" srcset="/img/loading.gif"></p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置。</p>
<p>有时候在生产环境我们会将这个文件进行备份。</p>
<p>rdb保存的文件是dump.rdb 都是在我们的配置文件中快照中进行配置的。</p>
<p>重新写配置文件，重新测试</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221154653313.png" srcset="/img/loading.gif" alt="image-20210221154653313"></p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221155020687.png" srcset="/img/loading.gif" alt="image-20210221155020687"></p>
<p>重新开启一个窗口连接redis</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221155451442.png" srcset="/img/loading.gif" alt="image-20210221155451442"></p>
<p>再次去原来的窗口，又发现了rdp</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221155600136.png" srcset="/img/loading.gif" alt="image-20210221155600136"></p>
<p>关闭第二个窗口</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221155839634.png" srcset="/img/loading.gif" alt="image-20210221155839634"></p>
<p>再次开机后，能看见之前存储的内容</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221162323469.png" srcset="/img/loading.gif" alt="image-20210221162323469"></p>
<p><strong>触发机制</strong></p>
<p>1、save的规则满足的情况下，会自动触发rdb规则<br>2、执行 flushall 命令，也会触发我们的rdb规则！<br>3、退出redis，也会产生 rdb 文件！</p>
<p>备份就自动生成一个 dump.rdb</p>
<p><strong>如何恢复rdb文件！</strong></p>
<p>1、只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！</p>
<p>2、查看需要存在的位置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; config get dir<br>1) &quot;dir&quot;<br>2) &quot;/usr/local/bin&quot; # 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据<br></code></pre></td></tr></table></figure>

<p><strong>优点：</strong><br>1、适合大规模的数据恢复！</p>
<p>2、对数据的完整性要不高！</p>
<p><strong>缺点：</strong></p>
<p>1、需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有了！</p>
<p>2、fork进程的时候，会占用一定的内容空间！！</p>
<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210119114219942.png" srcset="/img/loading.gif"></p>
<p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p><strong>Aof保存的是 appendonly.aof 文件</strong></p>
<p>默认是不开的，需要手动开启</p>
<p>我们只需要将 appendonly 改为yes就开启了 aof！</p>
<p>重启，redis 就可以生效了！</p>
<p>如果这个 aof 文件有错位，这时候 redis 是启动不起来的吗，我们需要修复这个aof文件</p>
<p>redis 给我们提供了一个工具 <code>redis-check-aof --fix appendonly.aof</code></p>
<p>如果文件正常，重启就可以直接恢复了！</p>
<p><strong>重写规则说明</strong></p>
<p>aof 默认就是文件的无限追加，文件会越来越大！</p>
<p>如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！</p>
<p><strong>优点和缺点！</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">appendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，<br>rdb完全够用！<br>appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字<br><span class="hljs-meta">#</span><span class="bash"> appendfsync always <span class="hljs-comment"># 每次修改都会 sync。消耗性能</span></span><br>appendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！<br><span class="hljs-meta">#</span><span class="bash"> appendfsync no <span class="hljs-comment"># 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span></span><br><span class="hljs-meta">#</span><span class="bash"> rewrite 重写，</span><br></code></pre></td></tr></table></figure>

<p><strong>优点：</strong><br>1、每一次修改都同步，文件的完整会更加好！</p>
<p>2、每秒同步一次，可能会丢失一秒的数据</p>
<p>3、从不同步，效率最高的！</p>
<p><strong>缺点：</strong></p>
<p>1、相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！</p>
<p>2、Aof 运行效率也要比 rdb 慢，所以我们redis默认的配置就是rdb持久化！</p>
<p><strong>扩展：</strong></p>
<p>1、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</p>
<p>2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</p>
<p>3、<strong>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</strong></p>
<p>4、同时开启两种持久化方式</p>
<ul>
<li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。</li>
</ul>
<p>5、性能建议</p>
<ul>
<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。</li>
<li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重<br>写可以改到适当的数值。</li>
<li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li>
</ul>
<h1 id="Redis-发布订阅-pub-sub"><a href="#Redis-发布订阅-pub-sub" class="headerlink" title="Redis 发布订阅(pub/sub)"></a>Redis 发布订阅(pub/sub)</h1><p>是一种<strong>消息通信模式</strong>：发送者(pub)发送消息，订阅者(sub)接收消息。微信、微博、关注系统！</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>订阅/发布消息图：</p>
<p>第一个：消息发送者， 第二个：频道 第三个：消息订阅者</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221173728102.png" srcset="/img/loading.gif" alt="image-20210221173728102"></p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210119140539964.png" srcset="/img/loading.gif"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2021011914060789.png" srcset="/img/loading.gif"></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210116175434236.png" srcset="/img/loading.gif"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>订阅端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; SUBSCRIBE kuangshenshuo # 订阅一个频道 kuangshenshuo<br>Reading messages... (press Ctrl-C to quit)<br>1) &quot;subscribe&quot;<br>2) &quot;kuangshenshuo&quot;<br>3) (integer) 1<br><span class="hljs-meta">#</span><span class="bash"> 等待读取推送的信息</span><br>1) &quot;message&quot; # 消息<br>2) &quot;kuangshenshuo&quot; # 那个频道的消息<br>3) &quot;hello,kuangshen&quot; # 消息的具体内容<br>1) &quot;message&quot;<br>2) &quot;kuangshenshuo&quot;<br>3) &quot;hello,redis&quot;<br></code></pre></td></tr></table></figure>

<p>发送端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; PUBLISH kuangshenshuo &quot;hello,kuangshen&quot; # 发布者发布消息到频道！<br>(integer) 1<br>127.0.0.1:6379&gt; PUBLISH kuangshenshuo &quot;hello,redis&quot; # 发布者发布消息到频道！<br>(integer) 1<br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。</p>
<p>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。</p>
<p>微信：</p>
<p>通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道！，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。</p>
<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。</p>
<p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<p><strong>主从复制的作用主要包括：</strong></p>
<p>1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p>
<p>2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p>
<p>3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p>
<p>4、高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
<p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：</p>
<p>1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</p>
<p>2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。</p>
<p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p>
<p>对于这种场景，我们可以使如下这种架构：</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210119140856469.png" srcset="/img/loading.gif"></p>
<p>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！</p>
<p>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>只配置从库，不用配置主库！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; info replication # 查看当前库的信息<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:master # 角色 master<br>connected_slaves:0 # 没有从机<br>master_replid:b63c90e6c501143759cb0e7f450bd1eb0c70882a<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure>

<p>复制3个配置文件，然后修改对应的信息<br>1、端口 【port 6379(端口号)】<br>2、pid 名字 【pidfile /var/run/redis_6379.pid】<br>3、log文件名字【logfile “6379.log”】<br>4、dump.rdb 名字【dbfilename dump6381.rdb】</p>
<p>修改完毕之后，启动我们的3个redis服务，可以通过进程信息查看</p>
<p><code>ps -cf|grep redis</code></p>
<h2 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h2><p>默认情况下，每台Redis服务器都是主节点； 我们一般情况下只用配置从机就好了！</p>
<p> 一主 （79）二从（80，81）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379 # SLAVEOF host 6379 找谁当自己的老大！<br>OK<br>127.0.0.1:6380&gt; info replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:slave # 当前角色是从机<br>master_host:127.0.0.1 # 可以的看到主机的信息<br>master_port:6379<br>master_link_status:up<br>master_last_io_seconds_ago:3<br>master_sync_in_progress:0<br>slave_repl_offset:14<br>slave_priority:100<br>slave_read_only:1<br>connected_slaves:0<br>master_replid:a81be8dd257636b2d3e7a9f595e69d73ff03774e<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:14<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:14<br><span class="hljs-meta">#</span><span class="bash"> 在主机中查看！</span><br>127.0.0.1:6379&gt; info replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:master<br>connected_slaves:1 # 多了从机的配置<br>slave0:ip=127.0.0.1,port=6380,state=online,offset=42,lag=1 # 多了从机的配置<br>master_replid:a81be8dd257636b2d3e7a9f595e69d73ff03774e<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:42<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:42<br></code></pre></td></tr></table></figure>

<p>如果两个都配置完了，就是有两个从机的</p>
<p>真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的</p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存！</p>
<p>主机写：</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2021011914110817.png" srcset="/img/loading.gif"></p>
<p>测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！</p>
<p>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值！</p>
<h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p>Slave 启动成功连接到 master 后会发送一个sync同步命令</p>
<p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<strong>master将传送整个数据文件到slave，并完成一次完全同步。</strong></p>
<p><strong>全量复制：</strong>而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
<p><strong>增量复制：</strong>Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p>
<p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！</p>
<h2 id="层层链路"><a href="#层层链路" class="headerlink" title="层层链路"></a>层层链路</h2><p>上一个M链接下一个 S！</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2021011914114815.png" srcset="/img/loading.gif"></p>
<p>这时候也可以完成我们的主从复制！</p>
<p>如果没有老大了，这个时候能不能选择一个老大出来呢？ 手动！</p>
<h2 id="谋朝篡位"><a href="#谋朝篡位" class="headerlink" title="谋朝篡位"></a>谋朝篡位</h2><p>如果主机断开了连接，我们可以使用 ==SLAVEOF no one== 让自己变成主机！其他的节点就可以手动连接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接！</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>（自动选举老大的模式）</p>
<p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。</p>
<p>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210119141235529.png" srcset="/img/loading.gif"></p>
<p>这里的哨兵有两个作用</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210119141251820.png" srcset="/img/loading.gif"></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong></p>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>1、在配置文件的文件再新建一个哨兵配置文件<code>vi sentinel.conf</code>并编写如下内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> sentinel monitor 被监控的名称 host port 1</span><br>sentinel monitor myredis 127.0.0.1 6379 1<br></code></pre></td></tr></table></figure>

<p>后面的这个数字1，代表至少有一个哨兵认为主机宕机时，该主机才被判定为宕机，slave投票看让谁接替成为主机，票数最多的，就会成为主机！</p>
<p>2、启动哨兵</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@kuangshen bin]# redis-sentinel kconfig/sentinel.conf<br>26607:X 31 Mar 2020 21:13:10.027 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo<br>26607:X 31 Mar 2020 21:13:10.027 # Redis version=5.0.8, bits=64,<br>commit=00000000, modified=0, pid=26607, just started<br>26607:X 31 Mar 2020 21:13:10.027 # Configuration loaded<br>_._<br>_.-``__ &#x27;&#x27;-._<br>_.-`` `. `_. &#x27;&#x27;-._ Redis 5.0.8 (00000000/0) 64 bit<br>.-`` .-```. ```\/ _.,_ &#x27;&#x27;-._<br>( &#x27; , .-` | `, ) Running in sentinel mode<br>|`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;| Port: 26379<br>| `-._ `._ / _.-&#x27; | PID: 26607<br>`-._ `-._ `-./ _.-&#x27; _.-&#x27;<br>|`-._`-._ `-.__.-&#x27; _.-&#x27;_.-&#x27;|<br>| `-._`-._ _.-&#x27;_.-&#x27; | http://redis.io<br>`-._ `-._`-.__.-&#x27;_.-&#x27; _.-&#x27;<br>|`-._`-._ `-.__.-&#x27; _.-&#x27;_.-&#x27;|<br>| `-._`-._ _.-&#x27;_.-&#x27; |<br>`-._ `-._`-.__.-&#x27;_.-&#x27; _.-&#x27;<br>`-._ `-.__.-&#x27; _.-&#x27;<br>`-._ _.-&#x27;<br>`-.__.-&#x27;<br>26607:X 31 Mar 2020 21:13:10.029 # WARNING: The TCP backlog setting of 511<br>cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value<br>of 128.<br>26607:X 31 Mar 2020 21:13:10.031 # Sentinel ID is<br>4c780da7e22d2aebe3bc20c333746f202ce72996<br>26607:X 31 Mar 2020 21:13:10.031 # +monitor master myredis 127.0.0.1 6379 quorum<br>1<br>26607:X 31 Mar 2020 21:13:10.031 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @<br>myredis 127.0.0.1 6379<br>26607:X 31 Mar 2020 21:13:10.033 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @<br>myredis 127.0.0.1 6379<br></code></pre></td></tr></table></figure>

<p>如果Master 节点断开了，这个时候就会从从机中随机选择一个服务器！ （这里面有一个投票算法！）</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221211540696.png" srcset="/img/loading.gif" alt="image-20210221211540696"></p>
<p>哨兵日志！</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210221211650440.png" srcset="/img/loading.gif" alt="image-20210221211650440"></p>
<p>如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！</p>
<p>优点：</p>
<p>1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</p>
<p>2、 主从可以切换，故障可以转移，系统的可用性就会更好</p>
<p>3、哨兵模式就是主从模式的升级，手动到自动，更加健壮！</p>
<p>缺点：</p>
<p>1、Redis 不好在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！</p>
<p>2、实现哨兵模式的配置其实是很麻烦的，里面有很多选择！</p>
<h3 id="哨兵模式的全部配置"><a href="#哨兵模式的全部配置" class="headerlink" title="哨兵模式的全部配置"></a>哨兵模式的全部配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Example sentinel.conf</span><br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel实例运行的端口 默认26379</span><br>port 26379<br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel的工作目录</span><br>dir /tmp<br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel监控的redis主节点的 ip port</span><br><span class="hljs-meta">#</span><span class="bash"> master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符<span class="hljs-string">&quot;.-_&quot;</span>组成。</span><br><span class="hljs-meta">#</span><span class="bash"> quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br>sentinel monitor mymaster 127.0.0.1 6379 2<br><span class="hljs-meta">#</span><span class="bash"> 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><br><span class="hljs-meta">#</span><span class="bash"> 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br>sentinel auth-pass mymaster MySUPER--secret-0123passw0rd<br><span class="hljs-meta">#</span><span class="bash"> 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel down-after-milliseconds mymaster 30000<br><span class="hljs-meta">#</span><span class="bash"> 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span><br>这个数字越小，完成failover所需的时间就越长，<br>但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。<br>可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。<br><span class="hljs-meta">#</span><span class="bash"> sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br>sentinel parallel-syncs mymaster 1<br><span class="hljs-meta">#</span><span class="bash"> 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span><br><span class="hljs-meta">#</span><span class="bash">1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><br><span class="hljs-meta">#</span><span class="bash">2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><br><span class="hljs-meta">#</span><span class="bash">3.当想要取消一个正在进行的failover所需要的时间。</span><br><span class="hljs-meta">#</span><span class="bash">4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="hljs-meta">#</span><span class="bash"> 默认三分钟</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel failover-timeout mymaster 180000<br><span class="hljs-meta">#</span><span class="bash"> SCRIPTS EXECUTION</span><br><span class="hljs-meta">#</span><span class="bash">配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><span class="hljs-meta">#</span><span class="bash">对于脚本的运行结果有以下规则：</span><br><span class="hljs-meta">#</span><span class="bash">若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="hljs-meta">#</span><span class="bash">若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="hljs-meta">#</span><span class="bash">如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="hljs-meta">#</span><span class="bash">一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br><span class="hljs-meta">#</span><span class="bash">通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="hljs-meta">#</span><span class="bash">通知脚本</span><br><span class="hljs-meta">#</span><span class="bash"> shell编程</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentinel notification-script mymaster /var/redis/notify.sh<br><span class="hljs-meta">#</span><span class="bash"> 客户端重新配置主节点参数脚本</span><br><span class="hljs-meta">#</span><span class="bash"> 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="hljs-meta">#</span><span class="bash"> 以下参数将会在调用脚本时传给脚本:</span><br><span class="hljs-meta">#</span><span class="bash"> &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="hljs-meta">#</span><span class="bash"> 目前&lt;state&gt;总是“failover”,</span><br><span class="hljs-meta">#</span><span class="bash"> &lt;role&gt;是“leader”或者“observer”中的一个。</span><br><span class="hljs-meta">#</span><span class="bash"> 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><br><span class="hljs-meta">#</span><span class="bash"> 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentinel client-reconfig-script mymaster /var/redis/reconfig.sh # 一般都是由运维来配置！<br></code></pre></td></tr></table></figure>

<h1 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h1><p>服务的高可用问题。</p>
<p>在这里我们不会详细的区分析解决方案的底层！</p>
<p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210119141626477.png" srcset="/img/loading.gif"></p>
<h2 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h2><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210119141654814.png" srcset="/img/loading.gif"></p>
<h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2021011914171586.png" srcset="/img/loading.gif"></p>
<p>但是这种方法会存在两个问题：</p>
<p>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</p>
<p>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
<h2 id="缓存击穿（量太大，缓存过期！）"><a href="#缓存击穿（量太大，缓存过期！）" class="headerlink" title="缓存击穿（量太大，缓存过期！）"></a>缓存击穿（量太大，缓存过期！）</h2><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="设置热点数据永不过期"><a href="#设置热点数据永不过期" class="headerlink" title="设置热点数据永不过期"></a><strong>设置热点数据永不过期</strong></h4><p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p>
<h4 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a><strong>加互斥锁</strong></h4><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210119141741444.png" srcset="/img/loading.gif"></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！</p>
<p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p><img src="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20210119141803494.png" srcset="/img/loading.gif"></p>
<p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a><strong>redis高可用</strong></h4><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）</p>
<h4 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a><strong>限流降级</strong></h4><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a><strong>数据预热</strong></h4><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
<p>笔记参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1S54y1R7SB">https://www.bilibili.com/video/BV1S54y1R7SB</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/02/19/%E5%88%86%E7%B1%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/NoSql%E4%BB%8B%E7%BB%8D/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">NoSql介绍</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/02/18/%E5%88%86%E7%B1%BB-Linux%E7%B3%BB%E7%BB%9F/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86/">
                        <span class="hidden-mobile">Linux账号与磁盘管理</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://mccontinuing.github.io/" target="_blank" rel="nofollow noopener"><span>Mccontinuing</span></a> <i class="iconfont icon-love"></i> <a href="http://http://qufang.xyz/" target="_blank" rel="nofollow noopener"><span>SGLMYD</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
